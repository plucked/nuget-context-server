Integrating BaGetter NuGet Server with Testcontainers for NUnit Integration Tests1. IntroductionPurposeThis report provides expert-level guidance for.NET developers and QA engineers on integrating a BaGetter NuGet server, running within a Docker container managed by Testcontainers.NET, into an NUnit integration testing workflow. The objective is to deliver a comprehensive, step-by-step approach, complete with robust code examples, enabling the effective implementation of this integration testing strategy.Problem ContextTesting applications that interact with NuGet feeds, such as package publishing tools, custom client applications, or components within build and deployment pipelines, presents unique challenges. Relying on public feeds like nuget.org for integration tests can introduce flakiness due to network issues, rate limiting, or unwanted external dependencies. Setting up and managing a dedicated, persistent private NuGet server solely for testing purposes can be complex and resource-intensive. There is a clear need for a realistic, isolated, and ephemeral NuGet server environment during the testing phase that can be reliably created and destroyed as part of the automated test execution lifecycle.Solution OverviewTestcontainers emerges as a powerful solution to these challenges. It is an open-source framework enabling developers to programmatically manage ephemeral Docker container instances directly within their test code.1 This approach allows tests to interact with real dependencies, like databases or message brokers, running in containers, rather than relying on mocks or in-memory fakes.3 For the specific need of a NuGet server, BaGetter, a lightweight, open-source, cross-platform NuGet and symbol server, serves as an excellent candidate for containerization.5By combining BaGetter with Testcontainers.NET within an NUnit testing framework, developers can achieve high-fidelity integration tests. This setup provides significant benefits: tests run against a genuine NuGet server environment, ensuring accurate behavior validation; each test fixture runs with an isolated server instance (or shares one predictably), preventing state conflicts between test runs; the setup and teardown processes are fully automated within the test lifecycle, simplifying test execution; and the entire testing environment becomes consistent and reproducible across different developer machines and CI/CD pipelines.7Report StructureThis report details the process in the following sections:
Selecting and Preparing Core Components: Identifying the appropriate BaGetter Docker image and the Testcontainers.NET library version.
Configuring the BaGetter Container via Testcontainers: Defining the necessary container settings using environment variables.
Implementing the BaGetter Testcontainer in C#: Writing the C# code to build and configure the container using ContainerBuilder.
Integrating with NUnit Test Fixtures: Managing the container's lifecycle using NUnit's setup and teardown attributes.
Interacting with BaGetter in NUnit Tests: Demonstrating how tests can push and search for packages on the containerized server using NuGet.Protocol.
Conclusion: Summarizing the approach and its benefits.
2. Selecting and Preparing Core ComponentsEffective integration testing begins with selecting the correct and most up-to-date components. This involves choosing a reliable Docker image for the BaGetter server and the appropriate version of the Testcontainers.NET library.2.1. Identifying the Recommended BaGetter Docker ImageRationale and RecommendationThe choice of Docker image is critical for stability and feature support. The original BaGetter project, hosted under loic-sharma/baget on Docker Hub 9, provided the initial official image.11 However, recent analysis of the associated GitHub repository suggests that this project may no longer be actively maintained, indicated by a significant number of open issues and discussions pointing towards a community fork.12Consequently, the recommended Docker image is from the actively maintained community fork, BaGetter, available on Docker Hub as bagetter/bagetter.13 This fork represents a progressive, community-driven development effort.14 It offers several advantages, including support for newer.NET versions (like.NET 8 as seen in its Dockerfile 16), compatibility with ARM64 architecture (enabling hosting on devices like Raspberry Pi 15), and a history of recent releases incorporating new features and bug fixes.17Image Source and Tag
Docker Hub Repository: bagetter/bagetter 13
Latest Stable Tag: As of the latest review, a recent stable version tag is 1.6.0.17 It is crucial to use a specific, stable version tag (like 1.6.0) rather than latest in test configurations. Relying on latest can lead to non-reproducible test runs if the underlying image changes unexpectedly. Always verify the absolute latest stable tag on Docker Hub or the project's release page 17 before implementation.
Default Internal Port and Critical DetailA key detail often overlooked when migrating from older documentation or examples based on loic-sharma/baget is the default internal port.
The bagetter/bagetter image exposes the BaGetter service on port 8080 inside the container.14
This contrasts with the port 80 commonly exposed and referenced in the Dockerfiles and documentation for the older loic-sharma/baget image.11
Failure to recognize this port change (from 80 to 8080) is a frequent source of errors during setup. Developers referencing older materials might incorrectly configure Testcontainers port bindings or wait strategies, leading to tests that cannot connect to the BaGetter service. Correctly specifying port 8080 for internal mapping and wait strategies when using the bagetter/bagetter image is essential for a successful setup.2.2. Identifying the Latest Testcontainers.NET VersionLibrary Purpose and VersionTestcontainers.NET is the library that facilitates the programmatic management of Docker containers within.NET testing frameworks.1 It provides APIs to define, start, configure, interact with, and stop containers as part of the test lifecycle.
Latest Stable Version: The latest stable version should be identified from the official NuGet gallery. As of the last review, version 4.4.0 was the latest stable release.23 Developers should always confirm and use the most current stable version available on NuGet.org at the time of implementation.
NuGet Installation and RequirementsThe core Testcontainers library can be installed into the NUnit test project using the.NET CLI:Bashdotnet add package Testcontainers --version <LatestVersion>
Replace <LatestVersion> with the actual latest stable version number (e.g., 4.4.0).23 While Testcontainers offers pre-configured modules for common services like PostgreSQL or Redis 1, there is no specific module for BaGetter. Therefore, the generic container configuration capabilities provided by the core Testcontainers package will be used.A fundamental prerequisite for using Testcontainers.NET is a functioning and accessible Docker environment. This typically involves having Docker Desktop installed and running on Windows or macOS, or Docker Engine running on Linux.4 Testcontainers interacts with the Docker daemon API to manage containers.3. Configuring the BaGetter Container via TestcontainersConfiguring the BaGetter instance running inside the Docker container is essential for tailoring its behavior to the needs of integration tests, such as setting API keys or modifying storage options. Testcontainers provides mechanisms to pass configuration into the container during startup.3.1. Configuration Strategy: Environment VariablesBaGetter, being an ASP.NET Core application, primarily relies on the standard ASP.NET Core configuration system. When running in Docker, the most common and idiomatic way to provide configuration is through environment variables.16 The ASP.NET Core configuration framework automatically maps environment variables to configuration keys. Nested configuration keys found in files like appsettings.json (e.g., "Database": { "Type": "Sqlite" }) are represented by environment variables using a double underscore (__) as a separator (e.g., Database__Type=Sqlite).31 This mapping behavior is facilitated by the Microsoft.Extensions.Configuration.EnvironmentVariables package, which is implicitly used in typical ASP.NET Core setups.33This convention aligns perfectly with Testcontainers.NET's capabilities. The ContainerBuilder class provides the WithEnvironment(string key, string value) method, which allows developers to set environment variables within the container directly from their C# test setup code.8 This grants fine-grained control over the BaGetter instance's configuration for each test fixture or scenario. For instance, one test suite might require read-through caching enabled via Mirror__Enabled, while another might need package deletion behavior changed via PackageDeletionBehavior, all configurable programmatically within the test setup.3.2. Essential BaGetter Environment Variables for TestingFor typical integration testing scenarios involving pushing and searching packages, several BaGetter configuration settings are pertinent. The bagetter/bagetter Docker image provides sensible defaults for many of these, simplifying the setup for basic tests. The key areas include the API key, storage, database, search, and the internal port.The following table summarizes essential configuration options, their corresponding environment variables, the defaults provided within the bagetter/bagetter:1.6.0 image (based on its Dockerfile and common ASP.NET Core practices), recommended values for testing, and an example of how to set them using Testcontainers' WithEnvironment method:
Environment VariableDescriptionBaGetter Default (in image bagetter/bagetter:1.6.0)Recommended Test ValueTestcontainers WithEnvironment ExampleSnippetsASPNETCORE_HTTP_PORTSInternal port BaGetter listens on8080Keep default(Handled by image)18ApiKeyAPI key required for package pushNone (anonymous push allowed)NUGET-TEST-API-KEY.WithEnvironment("ApiKey", "NUGET-TEST-API-KEY")11Storage__TypePackage storage backendFileSystemKeep default (FileSystem).WithEnvironment("Storage__Type", "FileSystem")16Storage__PathPath inside container for FileSystem storage/data (implies /data/packages)Keep default (/data).WithEnvironment("Storage__Path", "/data")16Database__TypeMetadata database engineSqliteKeep default (Sqlite).WithEnvironment("Database__Type", "Sqlite")16Database__ConnectionStringConnection string for the databaseData Source=/data/db/bagetter.dbKeep default.WithEnvironment("Database__ConnectionString", "Data Source=/data/db/bagetter.db")16Search__TypePackage search implementationDatabaseKeep default (Database).WithEnvironment("Search__Type", "Database")16Mirror__Enabled (Optional)Enable read-through cachingfalsetrue.WithEnvironment("Mirror__Enabled", "true")31Mirror__PackageSource (Optional)Upstream source for cachingNonehttps://api.nuget.org/v3/index.json.WithEnvironment("Mirror__PackageSource", "https://api.nuget.org/v3/index.json")31PackageDeletionBehavior (Optional)How package deletes are handled (Unlist/HardDelete)UnlistHardDelete.WithEnvironment("PackageDeletionBehavior", "HardDelete")31
The defaults provided by the bagetter/bagetter image (using SQLite for the database and the local filesystem within the /data volume mount point for package storage) are often sufficient for basic integration testing scenarios.16 This significantly simplifies the initial ContainerBuilder configuration, as developers typically only need to explicitly set the ApiKey for push tests or override other defaults for specific test requirements. This minimal configuration approach accelerates the setup process for standard use cases.4. Implementing the BaGetter Testcontainer in C#With the components selected and configuration strategy defined, the next step is to implement the container setup in C# using Testcontainers.NET.4.1. Using ContainerBuilderSince Testcontainers.NET does not provide a specialized module for BaGetter 27, the generic ContainerBuilder class is employed. This class offers a fluent API to define all aspects of the container configuration.8A typical instantiation and configuration sequence looks like this:C#using DotNet.Testcontainers.Builders;
using DotNet.Testcontainers.Containers;
using System;
using System.Threading.Tasks;

//... within your setup method...

const string baGetterImage = "bagetter/bagetter:1.6.0"; // Use the specific, latest stable tag
const string testApiKey = "NUGET-TEST-API-KEY";
const ushort baGetterInternalPort = 8080;

var baGetterContainerBuilder = new ContainerBuilder()
    // Specify the recommended image and tag
   .WithImage(baGetterImage) // [8, 35]

    // Set essential environment variables
   .WithEnvironment("ApiKey", testApiKey) // [8, 35]
    // Add other.WithEnvironment calls here if defaults need overriding

    // Map the container's internal port (8080) to a random available host port
   .WithPortBinding(baGetterInternalPort, true) // [1, 8, 37, 38]

    // Define the wait strategy to ensure the service is ready
   .WithWaitStrategy(Wait.ForUnixContainer()
       .UntilHttpRequestIsSucceeded(request => request
           .ForPort(baGetterInternalPort) // Check the internal port
           .ForPath("/v3/index.json"))); // Check the V3 service index [1, 37, 39]

// Build the container definition
IContainer container = baGetterContainerBuilder.Build(); // [1, 37]

// Start the container (typically done in NUnit's OneTimeSetUp)
// await container.StartAsync();
Key points in this builder configuration include:
Specifying the exact bagetter/bagetter image tag ensures consistency.
Setting the ApiKey environment variable is crucial for tests involving package pushes.
Using WithPortBinding(8080, true) is vital. It maps the container's internal port 8080 to a randomly assigned free port on the host machine. The true parameter prevents port conflicts that can occur if multiple tests or services attempt to use a fixed host port.37
Defining an appropriate wait strategy is non-negotiable for reliable tests.
4.2. Defining the Wait StrategyA common pitfall in containerized testing is assuming the service inside the container is ready as soon as the container itself reports a "running" state. This is often incorrect; the application might still be initializing. Testcontainers requires an explicit WaitStrategy to confirm the service's readiness before tests proceed, preventing flaky tests that fail due to connection refusals or timeouts.37For BaGetter, the most reliable approach is to wait for its core NuGet V3 API endpoint to become responsive. The recommended strategy is:Wait.ForUnixContainer().UntilHttpRequestIsSucceeded(request => request.ForPort(8080).ForPath("/v3/index.json")).1Let's break down this strategy:
Wait.ForUnixContainer(): Specifies that the strategy applies to a Linux-based container, which the bagetter/bagetter image is.16
.UntilHttpRequestIsSucceeded(...): Defines the core condition – waiting for a successful HTTP request. Testcontainers will repeatedly attempt the request until it succeeds or a timeout occurs.
request => request.ForPort(8080): Configures the HTTP request to target port 8080 inside the container, matching BaGetter's listening port.
.ForPath("/v3/index.json"): Specifies the path for the HTTP request. The /v3/index.json endpoint is the NuGet V3 service index, a fundamental part of the NuGet protocol.11 Waiting for this specific endpoint to return a success status (e.g., 200 OK) provides high confidence that the BaGetter service is fully initialized and ready to handle NuGet client requests.
While other strategies exist, such as Wait.UntilContainerIsHealthy() 39 (which relies on a HEALTHCHECK instruction in the Dockerfile) or simply waiting for the port to be available (Wait.UntilPortIsAvailable(8080) 39), the HTTP strategy targeting /v3/index.json is generally preferred for web services like BaGetter. It directly verifies the application's primary functionality rather than relying on lower-level checks (port listening) or potentially less specific health indicators. This direct check ensures the core NuGet API required by the tests is operational before proceeding.5. Integrating with NUnit Test FixturesTo optimize test execution and resource management, the BaGetter container should ideally be started once before a suite of related tests and stopped once after they have all completed. NUnit provides attributes specifically designed for this fixture-level setup and teardown.75.1. Lifecycle Management GoalThe primary goal is to avoid the significant overhead of starting and stopping a Docker container for every individual test method. Instead, the container's lifecycle should be tied to the lifecycle of an NUnit test fixture (``), ensuring it's available for all tests within that fixture while minimizing startup/shutdown time.425.2. NUnit Attributes: andNUnit offers two key attributes for managing fixture-level state:
: This attribute marks a method that NUnit will execute *once* before any tests within the containing (or ``) are run.43 It's the ideal location to perform expensive setup tasks, such as building the Testcontainer definition and starting the container asynchronously using await container.StartAsync().42 The method must have a signature of async Task to accommodate the asynchronous nature of Testcontainers operations.
``: This attribute marks a method that NUnit will execute once after all tests within the fixture have completed.43 It's the designated place for cleanup operations, primarily calling await container.DisposeAsync() on the Testcontainer instance.42 Testcontainers' DisposeAsync method handles the necessary Docker resource cleanup (stopping and removing the container, associated networks, etc.).4 This method must also be async Task.
5.3. Implementation Pattern (Base Class)A clean and reusable pattern for integrating Testcontainers with NUnit fixtures is to create an abstract base class. This base class encapsulates the container lifecycle logic using and, and derived test fixtures inherit this setup.C#using NUnit.Framework;
using DotNet.Testcontainers.Builders;
using DotNet.Testcontainers.Containers;
using DotNet.Testcontainers.Configurations; // Required for TestcontainersSettings
using Microsoft.Extensions.Logging; // Required for TestcontainersSettings.Logger
using System;
using System.Threading.Tasks;

// Optional: Configure Testcontainers logging (place outside the class or in a SetUpFixture)
// TestcontainersSettings.Logger = new Microsoft.Extensions.Logging.Console.ConsoleLogger("Testcontainers", (_, __) => true, true);

public abstract class BaGetterTestBase
{
    // Use static for OneTimeSetUp/TearDown in a base class to ensure single execution per fixture run
    protected static IContainer BaGetterContainer { get; private set; }
    protected static string BaGetterBaseUrl { get; private set; }
    protected const string TestApiKey = "NUGET-TEST-API-KEY"; // Example API Key shared by tests
    private static bool _isContainerInitialized = false; // Flag to prevent re-initialization

   
    public async Task GlobalSetup()
    {
        // Prevent re-initialization if already done (e.g., if multiple fixtures inherit)
        // A SetUpFixture is often better for truly global setup.
        // This check handles inheritance within a single test run context.
        if (_isContainerInitialized)
        {
            Console.WriteLine("BaGetter container already initialized, skipping setup.");
            return;
        }

        Console.WriteLine("Starting BaGetter container setup...");

        const string baGetterImage = "bagetter/bagetter:1.6.0"; // Use specific, latest stable tag
        const ushort baGetterInternalPort = 8080;

        BaGetterContainer = new ContainerBuilder()
           .WithImage(baGetterImage)
           .WithPortBinding(baGetterInternalPort, true) // Internal port 8080, random host port
           .WithEnvironment("ApiKey", TestApiKey)
            // Defaults (SQLite, FileSystem, Database Search) are generally fine for testing
           .WithWaitStrategy(Wait.ForUnixContainer()
               .UntilHttpRequestIsSucceeded(req => req
                   .ForPort(baGetterInternalPort)
                   .ForPath("/v3/index.json"))
               .WithStartupTimeout(TimeSpan.FromMinutes(2))) // Add a reasonable startup timeout
           .Build();

        try
        {
            await BaGetterContainer.StartAsync();
            BaGetterBaseUrl = $"http://{BaGetterContainer.Hostname}:{BaGetterContainer.GetMappedPublicPort(baGetterInternalPort)}";
            _isContainerInitialized = true; // Mark as initialized
            Console.WriteLine($"BaGetter container started successfully at {BaGetterBaseUrl}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to start BaGetter container: {ex.Message}");
            // Optionally dump container logs on failure
            if (BaGetterContainer!= null)
            {
                 try
                 {
                     var logs = await BaGetterContainer.GetLogsAsync();
                     Console.WriteLine("Container Logs:\n" + logs.Stdout + "\n" + logs.Stderr);
                 }
                 catch (Exception logEx)
                 {
                     Console.WriteLine($"Failed to get container logs: {logEx.Message}");
                 }
            }
            throw; // Re-throw the exception to fail the setup
        }
    }

   
    public async Task GlobalTeardown()
    {
        if (BaGetterContainer!= null && _isContainerInitialized)
        {
            Console.WriteLine("Disposing BaGetter container...");
            await BaGetterContainer.DisposeAsync();
            BaGetterContainer = null; // Clear static reference
            _isContainerInitialized = false; // Reset flag
            Console.WriteLine("BaGetter container disposed.");
        }
        else
        {
             Console.WriteLine("BaGetter container was not initialized or already disposed.");
        }
    }
}

// Example Test Fixture using the base class

public class MyPackagePublishTests : BaGetterTestBase
{
   
    public void Container_IsAvailable_InTest()
    {
         Assert.NotNull(BaGetterContainer, "Container should be initialized by base class setup.");
         Assert.IsNotEmpty(BaGetterBaseUrl, "Base URL should be set by base class setup.");
         Console.WriteLine($"Test running against BaGetter at: {BaGetterBaseUrl}");
         // Test logic using BaGetterBaseUrl and TestApiKey would go here...
    }

   
    public void AnotherTest_UsingSameContainer()
    {
        Assert.NotNull(BaGetterContainer, "Container should be the same instance for all tests in the fixture.");
        // More test logic...
    }
}
In this pattern, any class decorated with `` that inherits from BaGetterTestBase will automatically have the BaGetter container started before its tests run and disposed of afterward. The derived tests can access the running container instance via the protected static IContainer BaGetterContainer property and its connection details via BaGetterBaseUrl. The use of static for the container and URL ensures they are shared across all test method instances within that fixture run, managed by the single execution of OneTimeSetUp and OneTimeTearDown. The _isContainerInitialized flag adds robustness against potential multiple initializations in complex scenarios.5.4. Alternative: ``NUnit also provides the attribute, which can be applied to a class within a namespace. Methods marked with and `` within a SetUpFixture class will run once before and after all tests within that namespace, respectively.44 This can achieve a similar container lifecycle management goal, potentially spanning multiple test fixtures within the same namespace. However, sharing the container instance and its dynamic details (like the base URL) from the SetUpFixture to the individual TestFixture classes can sometimes be less direct than using a base class inheritance model. The base class approach often provides a clearer and more object-oriented way for test fixtures to access the shared container resource.Test Isolation vs. Performance ConsiderationsEmploying `` offers substantial performance gains by reusing the same container instance for all tests within a fixture.7 This avoids the costly process of container creation and destruction for each test. However, this reuse implies that all tests within that fixture operate on the same BaGetter instance, sharing its state (uploaded packages, etc.).For many BaGetter testing scenarios (e.g., testing a package push command, then testing a search command), this shared state is acceptable or even desirable. If strict test isolation is required, where each test method must start with a pristine BaGetter instance, developers would need to forgo the OneTimeSetUp optimization and manage the container lifecycle per test (using and), accepting the performance penalty. Alternatively, for stateful dependencies like databases (less common for direct BaGetter interaction testing unless testing its database layer), tools like Respawn 45 could be used within to reset the state between tests while still reusing the container managed by. For typical NuGet client interactions (push, search, list), the fixture-level sharing provided by OneTimeSetUp strikes an excellent balance between test speed and reliability.6. Interacting with BaGetter in NUnit TestsOnce the BaGetter container is running and managed by the NUnit fixture lifecycle, tests need to interact with it to perform actions like pushing or searching for packages.6.1. Obtaining Dynamic Connection DetailsBecause Testcontainers maps the container's internal port (8080 for BaGetter) to a random available port on the host machine 37, tests cannot rely on a fixed URL. They must dynamically retrieve the assigned host port and the container's accessible hostname after the container starts.Within the BaGetterTestBase class shown previously, these details are captured in the `` method:
Hostname: BaGetterContainer.Hostname provides the hostname or IP address where the container's mapped ports are accessible from the host.1 This value depends on the Docker environment.
Mapped Port: BaGetterContainer.GetMappedPublicPort(8080) retrieves the randomly assigned host port corresponding to the container's internal port 8080.1
Base URL: These are combined to form the base URL for interacting with the BaGetter service: BaGetterBaseUrl = $"http://{BaGetterContainer.Hostname}:{BaGetterContainer.GetMappedPublicPort(8080)}";. Tests inheriting from BaGetterTestBase can use the BaGetterBaseUrl property.
6.2. Using NuGet.Protocol for InteractionsWhile HTTP requests could be made directly, the recommended approach for interacting with the NuGet feed from C# test code is to use the official NuGet.Protocol library.47 This library provides strongly-typed clients and abstractions for common NuGet operations like searching, pushing, downloading, and listing packages.Install the package into the test project:Bashdotnet add package NuGet.Protocol --version <LatestVersion>
(Verify and use the latest stable version from NuGet.org 47).Within a test method, instantiate the necessary NuGet.Protocol objects, using the dynamically obtained BaGetterBaseUrl:C#using NuGet.Configuration;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;
using NuGet.Common; // Required for NullLogger
using System.Threading;
using System.Threading.Tasks;
using NUnit.Framework; // Assuming usage within NUnit tests

//... inside an async NUnit method inheriting from BaGetterTestBase...

ILogger logger = NullLogger.Instance; // Use NullLogger or a configured logger
CancellationToken cancellationToken = CancellationToken.None;

// Construct the full V3 service index URL using the dynamic base URL
string serviceIndexUrl = $"{BaGetterBaseUrl}/v3/index.json"; // [11, 28]
var packageSource = new PackageSource(serviceIndexUrl);

// Create a repository instance pointing to the containerized BaGetter
var repository = Repository.Factory.GetCoreV3(packageSource);

// Use a cache context for potentially better performance during interactions
var sourceCacheContext = new SourceCacheContext
{
    NoCache = true, // Disable caching for tests to ensure fresh results, or configure as needed
    DirectDownload = true
};
6.3. Example: Pushing a PackageTo test package publishing functionality, tests can use the PackageUpdateResource provided by NuGet.Protocol.47 This resource corresponds to the NuGet V3 Push and Delete API.Here's an example NUnit test method demonstrating a package push:C#
public async Task PushPackage_Succeeds()
{
    // Arrange: Prepare a dummy package file
    // In a real scenario, this might involve packing a test project or using a pre-built test package.
    string packageId = $"MyTestPackage.FromTest.{Guid.NewGuid().ToString("N").Substring(0, 8)}";
    string packageVersion = "1.0.0";
    string packageFileName = $"{packageId}.{packageVersion}.nupkg";
    string packagePath = Path.Combine(TestContext.CurrentContext.WorkDirectory, packageFileName);

    // Assume CreateDummyNupkg creates a minimal, valid.nupkg file at packagePath
    // This helper function is specific to the test setup and not part of Testcontainers/NuGet.Protocol
    CreateDummyNupkg(packagePath, packageId, packageVersion);
    Assert.IsTrue(File.Exists(packagePath), "Dummy package file should exist.");

    // Get the push resource from the repository
    var pushResource = await repository.GetResourceAsync<PackageUpdateResource>(cancellationToken);
    Assert.NotNull(pushResource, "PackageUpdateResource should be available.");

    // Act: Push the package
    try
    {
        await pushResource.Push(
            packagePath,
            symbolSource: null, // Specify symbol server URL if pushing symbols
            timeoutInSeconds: 120, // Increase timeout if needed
            disableBuffering: false, // Buffering is usually fine for tests
            getApiKey: source => TestApiKey, // Provide the API key configured via WithEnvironment [50]
            getSymbolApiKey: null, // API key for symbol server, if used
            noServiceEndpoint: false, // Use the standard /api/v2/package endpoint suffix if needed (V3 uses index)
            skipDuplicate: false, // Fail if package already exists
            log: logger);

        TestContext.WriteLine($"Successfully pushed {packageFileName}");
    }
    catch (Exception ex)
    {
        Assert.Fail($"Package push failed: {ex.ToString()}");
    }
    finally
    {
        // Clean up the dummy package file
        if (File.Exists(packagePath))
        {
            File.Delete(packagePath);
        }
    }

    // Assert: Optionally, verify the package now exists using a search query (see next example)
}

// Helper method (example implementation - adapt as needed)
private void CreateDummyNupkg(string path, string id, string version)
{
    // This is a placeholder. A real implementation would use NuGet.Packaging
    // or a similar library to create a valid, minimal.nupkg file.
    // For simplicity here, we just create an empty file.
    // A more robust approach is needed for actual validation.
    Directory.CreateDirectory(Path.GetDirectoryName(path));
    using (var fs = File.Create(path)) { /* Create empty file */ }
    TestContext.WriteLine($"Created dummy package file at: {path}");

    // A better approach involves using NuGet.Packaging:
    /*
    using NuGet.Packaging;
    var builder = new PackageBuilder();
    builder.Id = id;
    builder.Version = new NuGetVersion(version);
    builder.Authors.Add("Test Author");
    builder.Description = "Test Package";
    // Add a dummy file to avoid empty package errors
    builder.Files.Add(new PhysicalPackageFile { SourcePath = path, TargetPath = "lib/netstandard2.0/dummy.dll" }); // Requires a real file or stream
    using (var stream = File.OpenWrite(path))
    {
        builder.Save(stream);
    }
    */
}
The crucial part here is the getApiKey delegate, which provides the TestApiKey that was configured as an environment variable for the BaGetter container. This authenticates the push operation. The nuget push command-line tool operates similarly, requiring an API key for authenticated feeds.506.4. Example: Searching for a PackageTo verify that packages are correctly indexed or to retrieve package information, tests can use the PackageSearchResource.47 This interacts with the NuGet V3 Search API.C#
public async Task SearchPackage_FindsPushedPackage()
{
    // Arrange: Ensure a package exists (push it first)
    string packageId = $"MySearchablePackage.{Guid.NewGuid().ToString("N").Substring(0, 8)}";
    string packageVersion = "1.0.0";
    string packageFileName = $"{packageId}.{packageVersion}.nupkg";
    string packagePath = Path.Combine(TestContext.CurrentContext.WorkDirectory, packageFileName);
    CreateDummyNupkg(packagePath, packageId, packageVersion); // Create the package

    var pushResource = await repository.GetResourceAsync<PackageUpdateResource>(cancellationToken);
    await pushResource.Push(packagePath, null, 60, false, src => TestApiKey, null, false, false, logger);
    TestContext.WriteLine($"Pushed package {packageId} for search test.");
    File.Delete(packagePath); // Clean up local file after push

    // Allow time for indexing if necessary (usually fast with SQLite/Database search)
    await Task.Delay(TimeSpan.FromSeconds(2));

    // Get the search resource
    var searchResource = await repository.GetResourceAsync<PackageSearchResource>(cancellationToken);
    Assert.NotNull(searchResource, "PackageSearchResource should be available.");
    var searchFilter = new SearchFilter(includePrerelease: true); // Include prerelease versions in search

    // Act: Search for the specific package ID
    IEnumerable<IPackageSearchMetadata> results = null;
    try
    {
        results = await searchResource.SearchAsync(
            packageId, // Search term (the package ID)
            searchFilter,
            skip: 0, // Start from the first result
            take: 10, // Limit the number of results
            log: logger,
            cancellationToken: cancellationToken);
    }
    catch (Exception ex)
    {
        Assert.Fail($"Package search failed: {ex.ToString()}");
    }

    // Assert: Verify the package was found
    Assert.NotNull(results, "Search results should not be null.");
    var foundPackage = results.FirstOrDefault(p => p.Identity.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase));

    Assert.NotNull(foundPackage, $"Package with ID '{packageId}' should be found.");
    Assert.AreEqual(packageVersion, foundPackage.Identity.Version.ToString(), "Found package should have the correct version.");
    TestContext.WriteLine($"Successfully found package {foundPackage.Identity.Id} version {foundPackage.Identity.Version}.");
}
This example demonstrates searching for a specific package ID after pushing it. The SearchFilter allows controlling whether pre-release versions are included.52 The skip and take parameters handle pagination.Using NuGet.Protocol within the tests allows for powerful, integrated validation scenarios. For example, a test can programmatically push a package and then immediately query the search endpoint to confirm that the package was received and indexed correctly by the BaGetter instance. This provides a much more robust verification of the end-to-end functionality compared to simply checking if the container is running or if a push command returned success without subsequent validation.7. ConclusionRecapThis report has detailed a comprehensive approach for integrating a BaGetter NuGet server into NUnit integration tests using Testcontainers.NET. The key steps involve:
Selecting the actively maintained bagetter/bagetter Docker image and noting its internal port (8080).
Using the latest stable version of the Testcontainers NuGet package.
Leveraging the generic ContainerBuilder to configure the BaGetter container, specifying the image, mapping port 8080 to a random host port, setting environment variables (like ApiKey) for configuration, and defining a reliable HTTP wait strategy targeting the /v3/index.json endpoint.
Managing the container's lifecycle efficiently using NUnit's and attributes, typically within a shared base test class, to start the container once per fixture and dispose of it afterwards.
Interacting with the containerized BaGetter instance from within NUnit tests using the NuGet.Protocol library to perform actions like pushing and searching for packages, utilizing the dynamically obtained hostname and mapped port.
Benefits RevisitedAdopting this strategy offers significant advantages for testing.NET applications that depend on NuGet feeds:
Realism: Tests execute against a genuine BaGetter server, providing high confidence that the application interacts correctly with a real NuGet feed implementation.
Isolation: Each test fixture runs against a cleanly started container instance (or predictably shares one), preventing state leakage between test runs and ensuring reproducibility.
Automation: The entire lifecycle of the NuGet server dependency (creation, configuration, startup, shutdown, cleanup) is automated within the test execution framework.
Maintainability: Test setup is defined in code alongside the tests, making it version-controlled, easier to understand, and less prone to configuration drift compared to managing external test environments.
Consistency: Tests run reliably across different developer machines and CI/CD environments, provided Docker is available.
Further ConsiderationsWhile this report covers the core setup, developers can extend this foundation:
Symbol Server Testing: Configure BaGetter for symbol serving and test symbol package pushing and retrieval using NuGet.Protocol or debugging tools.11
CI/CD Integration: Integrate these Testcontainers-based tests into CI/CD pipelines. This typically requires ensuring Docker is available and runnable within the build agent environment.37
Advanced Testcontainers: Explore more advanced features like custom networks for multi-container scenarios or resource reuse across multiple test assemblies (though careful state management is needed).4
Alternative Storage/Database: Configure BaGetter via environment variables to use different backends (e.g., Azure Blob Storage, PostgreSQL) if tests need to validate interactions with those specific configurations.29
By implementing the techniques outlined in this report,.NET teams can significantly enhance the quality and reliability of their integration tests for applications interacting with NuGet package feeds.